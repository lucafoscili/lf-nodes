{"id":"490c6ec8-e5c0-4d70-b443-35a8914773eb","revision":0,"last_node_id":30,"last_link_id":51,"nodes":[{"id":25,"type":"LF_String","pos":[1060,-290],"size":[920,230],"flags":{},"order":6,"mode":0,"inputs":[{"localized_name":"string","name":"string","type":"STRING","widget":{"name":"string"},"link":37},{"localized_name":"enable_history","name":"enable_history","type":"BOOLEAN","widget":{"name":"enable_history"},"link":null},{"localized_name":"randomize","name":"randomize","type":"BOOLEAN","widget":{"name":"randomize"},"link":null},{"localized_name":"seed","name":"seed","type":"INT","widget":{"name":"seed"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_HISTORY","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"string","name":"string","type":"STRING","slot_index":0,"links":null},{"localized_name":"string_list","name":"string_list","shape":6,"type":"STRING","slot_index":1,"links":[38]}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_String","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["",true,{"nodes":[{"icon":"history","id":"class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"tooltip\": \"Boolean value.\"}),\n                \"enable_history\": (\"BOOLEAN\", {\"default\": True, \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"}),\n            },\n            \"optional\": {\n                \"json_input\": (\"KUL_HISTORY\", {\"default\": {}}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, node_id: str, boolean: bool, enable_history: bool, json_input: dict = {}):\n        boolean = normalize_list_to_value(boolean)\n        enable_history = normalize_list_to_value(enable_history)\n        json_input = normalize_json_input(json_input)\n\n        nodes = json_input.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": node_id, \n            \"dataset\": dataset\n        })\n\n        return (boolean, [boolean])","description":"Execution date: 31/10/2024, 05:47:54.","value":"class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"tooltip\": \"Boolean value.\"}),\n                \"enable_history\": (\"BOOLEAN\", {\"default\": True, \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"}),\n            },\n            \"optional\": {\n                \"json_input\": (\"KUL_HISTORY\", {\"default\": {}}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, node_id: str, boolean: bool, enable_history: bool, json_input: dict = {}):\n        boolean = normalize_list_to_value(boolean)\n        enable_history = normalize_list_to_value(enable_history)\n        json_input = normalize_json_input(json_input)\n\n        nodes = json_input.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": node_id, \n            \"dataset\": dataset\n        })\n\n        return (boolean, [boolean])"},{"icon":"history","id":"class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"forceInput\": True, \"tooltip\": \"Boolean value.\"}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, node_id: str, boolean: bool):\n        display_boolean = normalize_input_list(boolean)\n\n        if len(display_boolean) > 1:\n            markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n        else:\n            markdown_value = str(display_boolean[0]) \n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": node_id, \n            \"value\": markdown_value,\n        })\n\n        return (boolean,)","description":"Execution date: 31/10/2024, 05:47:54.","value":"class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"forceInput\": True, \"tooltip\": \"Boolean value.\"}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, node_id: str, boolean: bool):\n        display_boolean = normalize_input_list(boolean)\n\n        if len(display_boolean) > 1:\n            markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n        else:\n            markdown_value = str(display_boolean[0]) \n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": node_id, \n            \"value\": markdown_value,\n        })\n\n        return (boolean,)"}]},827294970991090,"randomize",{"nodes":[{"icon":"history","id":"class LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)"},{"icon":"history","id":"class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, **kwargs: dict):\n        boolean: bool = normalize_list_to_value(kwargs.get(\"boolean\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes: list[dict] = ui_widget.get(\"nodes\", [])\n        dataset: dict = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n\n        if randomize:\n            result = randomize_from_history(nodes, seed)\n            boolean = True if result.lower() == \"true\" else False\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset,\n        })\n\n        return (boolean, [boolean])","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, **kwargs: dict):\n        boolean: bool = normalize_list_to_value(kwargs.get(\"boolean\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes: list[dict] = ui_widget.get(\"nodes\", [])\n        dataset: dict = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n\n        if randomize:\n            result = randomize_from_history(nodes, seed)\n            boolean = True if result.lower() == \"true\" else False\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset,\n        })\n\n        return (boolean, [boolean])"},{"icon":"history","id":"class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_boolean: bool = normalize_input_list(kwargs.get(\"boolean\"))\n\n        if isinstance(display_boolean, list):\n            if len(display_boolean) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n            else:\n                markdown_value = str(display_boolean[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"boolean\"),)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_boolean: bool = normalize_input_list(kwargs.get(\"boolean\"))\n\n        if isinstance(display_boolean, list):\n            if len(display_boolean) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n            else:\n                markdown_value = str(display_boolean[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"boolean\"),)"},{"icon":"history","id":"class LF_DisplayFloat:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Float value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"float\",)\n    RETURN_TYPES = (\"FLOAT\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_float: float = normalize_input_list(kwargs.get(\"float\"))\n\n        if isinstance(display_float, list):\n            if len(display_float) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_float))\n            else:\n                markdown_value = str(display_float[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayfloat\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"float\"),)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_DisplayFloat:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Float value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"float\",)\n    RETURN_TYPES = (\"FLOAT\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_float: float = normalize_input_list(kwargs.get(\"float\"))\n\n        if isinstance(display_float, list):\n            if len(display_float) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_float))\n            else:\n                markdown_value = str(display_float[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayfloat\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"float\"),)"},{"icon":"history","id":"class LF_DisplayInteger:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Integer value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"integer\",)\n    RETURN_TYPES = (\"INT\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_integer: int = normalize_input_list(kwargs.get(\"integer\"))\n\n        if isinstance(display_integer, list):\n            if len(display_integer) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_integer))\n            else:\n                markdown_value = str(display_integer[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayinteger\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"integer\"),)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_DisplayInteger:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Integer value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"integer\",)\n    RETURN_TYPES = (\"INT\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_integer: int = normalize_input_list(kwargs.get(\"integer\"))\n\n        if isinstance(display_integer, list):\n            if len(display_integer) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_integer))\n            else:\n                markdown_value = str(display_integer[0])\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayinteger\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"integer\"),)"},{"icon":"history","id":"class LF_DisplayPrimitiveAsJSON:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Integer value.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0.0, \n                    \"forceInput\": True, \n                    \"step\": 0.1, \n                    \"tooltip\": \"Float value.\"\n                }),\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"forceInput\": True, \n                    \"multiline\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"json\",)\n    RETURN_TYPES = (\"JSON\",)\n\n    def on_exec(self, **kwargs: dict):\n        integer_list: int = normalize_input_list(kwargs.get(\"integer\"))\n        float_list: float = normalize_input_list(kwargs.get(\"float\"))\n        string_list: str = normalize_input_list(kwargs.get(\"string\"))\n        boolean_list: bool = normalize_input_list(kwargs.get(\"boolean\"))\n\n        nodes: list[dict] = []\n        dataset: dict = {\"nodes\": nodes}\n\n        if boolean_list:\n            for idx, value in enumerate(boolean_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"boolean_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"boolean_{idx}\", \"value\": \"boolean\"\n                })\n        \n        if float_list:\n            for idx, value in enumerate(float_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"float_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"float_{idx}\", \"value\": \"float\"\n                })\n        \n        if integer_list:\n            for idx, value in enumerate(integer_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"integer_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"integer_{idx}\", \"value\": \"integer\"\n                })\n        \n        if string_list:\n            for idx, value in enumerate(string_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"string_{idx}\", \"value\": value}],\n                    \"description\": value, \"id\": f\"string_{idx}\", \"value\": \"string\"\n                })\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayprimitiveasjson\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": dataset,\n        })\n\n        return (dataset,)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_DisplayPrimitiveAsJSON:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"forceInput\": True, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Integer value.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0.0, \n                    \"forceInput\": True, \n                    \"step\": 0.1, \n                    \"tooltip\": \"Float value.\"\n                }),\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"forceInput\": True, \n                    \"multiline\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"forceInput\": True, \n                    \"tooltip\": \"Boolean value.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"json\",)\n    RETURN_TYPES = (\"JSON\",)\n\n    def on_exec(self, **kwargs: dict):\n        integer_list: int = normalize_input_list(kwargs.get(\"integer\"))\n        float_list: float = normalize_input_list(kwargs.get(\"float\"))\n        string_list: str = normalize_input_list(kwargs.get(\"string\"))\n        boolean_list: bool = normalize_input_list(kwargs.get(\"boolean\"))\n\n        nodes: list[dict] = []\n        dataset: dict = {\"nodes\": nodes}\n\n        if boolean_list:\n            for idx, value in enumerate(boolean_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"boolean_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"boolean_{idx}\", \"value\": \"boolean\"\n                })\n        \n        if float_list:\n            for idx, value in enumerate(float_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"float_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"float_{idx}\", \"value\": \"float\"\n                })\n        \n        if integer_list:\n            for idx, value in enumerate(integer_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"integer_{idx}\", \"value\": str(value)}],\n                    \"description\": str(value), \"id\": f\"integer_{idx}\", \"value\": \"integer\"\n                })\n        \n        if string_list:\n            for idx, value in enumerate(string_list):\n                nodes.append({\n                    \"children\": [{\"id\": f\"string_{idx}\", \"value\": value}],\n                    \"description\": value, \"id\": f\"string_{idx}\", \"value\": \"string\"\n                })\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayprimitiveasjson\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": dataset,\n        })\n\n        return (dataset,)"},{"icon":"history","id":"class LF_DisplayString:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"forceInput\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"string\",)\n    RETURN_TYPES = (\"STRING\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_string:str = normalize_input_list(kwargs.get(\"string\"))\n\n        if isinstance(display_string, list):\n            if len(display_string) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_string))\n            else:\n                markdown_value = display_string[0]\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displaystring\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"string\"),)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_DisplayString:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"forceInput\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"string\",)\n    RETURN_TYPES = (\"STRING\",)\n\n    def on_exec(self, **kwargs: dict):\n        display_string:str = normalize_input_list(kwargs.get(\"string\"))\n\n        if isinstance(display_string, list):\n            if len(display_string) > 1:\n                markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_string))\n            else:\n                markdown_value = display_string[0]\n        else:\n            markdown_value = \"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displaystring\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"value\": markdown_value,\n        })\n\n        return (kwargs.get(\"string\"),)"},{"icon":"history","id":"class LF_Float:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0, \n                    \"step\": 0.1, \n                    \"tooltip\": \"Float value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"float\", \"float_list\")\n    RETURN_TYPES = (\"FLOAT\", \"FLOAT\")\n\n    def on_exec(self, **kwargs: dict):\n        float_input: float = normalize_list_to_value(kwargs.get(\"float\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(float_input), nodes)\n\n        if randomize:\n            float_input = float(randomize_from_history(nodes, seed))\n                \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}float\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset,\n        })\n\n        return (float_input, [float_input])","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_Float:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"float\": (Input.FLOAT, {\n                    \"default\": 0, \n                    \"step\": 0.1, \n                    \"tooltip\": \"Float value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"float\", \"float_list\")\n    RETURN_TYPES = (\"FLOAT\", \"FLOAT\")\n\n    def on_exec(self, **kwargs: dict):\n        float_input: float = normalize_list_to_value(kwargs.get(\"float\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(float_input), nodes)\n\n        if randomize:\n            float_input = float(randomize_from_history(nodes, seed))\n                \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}float\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset,\n        })\n\n        return (float_input, [float_input])"},{"icon":"history","id":"class LF_Integer:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Integer value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"int\", \"int_list\")\n    RETURN_TYPES = (\"INT\", \"INT\")\n\n    def on_exec(self, **kwargs: dict):\n        integer_input: int = normalize_list_to_value(kwargs.get(\"integer\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(integer_input), nodes)\n\n        if randomize:\n            integer_input = int(randomize_from_history(nodes, seed))\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}integer\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset\n        })\n\n        return (integer_input, [integer_input])","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_Integer:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"integer\": (Input.INTEGER, {\n                    \"default\": 0, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Integer value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"int\", \"int_list\")\n    RETURN_TYPES = (\"INT\", \"INT\")\n\n    def on_exec(self, **kwargs: dict):\n        integer_input: int = normalize_list_to_value(kwargs.get(\"integer\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(integer_input), nodes)\n\n        if randomize:\n            integer_input = int(randomize_from_history(nodes, seed))\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}integer\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"dataset\": dataset\n        })\n\n        return (integer_input, [integer_input])"},{"icon":"history","id":"class LF_RandomBoolean:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"chance_true\": (Input.FLOAT, {\n                    \"default\": 50.0, \n                    \"step\": 1, \n                    \"min\": 0, \n                    \"max\": 100, \n                    \"tooltip\": \"Percentage chance for True output, 0-100.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_PROGRESSBAR, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, **kwargs: dict):\n        chance_true: str = normalize_list_to_value(kwargs.get(\"chance_true\"))\n        \n        percentage = max(0, min(100, chance_true))\n        random_value = random.uniform(0, 100)\n\n        result = random_value <= percentage\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}randomboolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"bool\": result,\n            \"roll\": random_value,\n        })\n\n        return (result, [result])\n\n    @classmethod\n    def IS_CHANGED(cls, **kwargs):\n        return float(\"NaN\")","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_RandomBoolean:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"chance_true\": (Input.FLOAT, {\n                    \"default\": 50.0, \n                    \"step\": 1, \n                    \"min\": 0, \n                    \"max\": 100, \n                    \"tooltip\": \"Percentage chance for True output, 0-100.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_PROGRESSBAR, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, **kwargs: dict):\n        chance_true: str = normalize_list_to_value(kwargs.get(\"chance_true\"))\n        \n        percentage = max(0, min(100, chance_true))\n        random_value = random.uniform(0, 100)\n\n        result = random_value <= percentage\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}randomboolean\", {\n            \"node\": kwargs.get(\"node_id\"),\n            \"bool\": result,\n            \"roll\": random_value,\n        })\n\n        return (result, [result])\n\n    @classmethod\n    def IS_CHANGED(cls, **kwargs):\n        return float(\"NaN\")"},{"icon":"history","id":"class LF_Something2Number:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"JSON\": (Input.JSON, {\n                    \"tooltip\": \"JSON value to convert to numbers.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"tooltip\": \"Boolean value to convert to numbers.\"\n                }),\n                \"string\": (Input.STRING, {\n                    \"tooltip\": \"String value to convert to numbers.\"\n                }),\n                \"integer\": (Input.INTEGER, {\n                    \"tooltip\": \"Integer value to convert to numbers.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"tooltip\": \"Float value to convert to numbers.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, False, False, False, True, True)\n    RETURN_NAMES = (\"float_sum\", \"int_sum\", \"float_list\", \"int_list\")\n    RETURN_TYPES = (\"FLOAT\", \"INT\", \"FLOAT\", \"INT\")\n\n    def on_exec(self, **kwargs: dict):\n        def extract_numbers(data):\n            if isinstance(data, bool):\n                i_val = 1 if data else 0\n                f_val = 1.0 if data else 0.0\n                float_values.append(f_val)\n                integer_values.append(i_val)\n                breakdown.append(f\"**boolean** detected => {f_val} (float) {i_val} (int)\")\n            elif isinstance(data, (int, float)):\n                i_val = int(data)\n                f_val = float(data)\n                float_values.append(f_val)\n                integer_values.append(i_val)\n                breakdown.append(f\"**number** detected => {f_val} (float) {i_val} (int)\")\n            elif isinstance(data, str):\n                try:\n                    f_val = float(data.strip())\n                    i_val = int(f_val)\n                    float_values.append(f_val)\n                    integer_values.append(i_val)\n                    breakdown.append(f\"**string** detected => {f_val} (float) {i_val} (int)\")\n                except ValueError:\n                    try:\n                        parsed_json = json.loads(data)\n                        extract_numbers(parsed_json)\n                    except json.JSONDecodeError:\n                        pass\n            elif isinstance(data, dict):\n                for value in data.values():\n                    extract_numbers(value)\n            elif isinstance(data, (list, tuple, set)):\n                for item in data:\n                    extract_numbers(item)\n\n        empty = \"*Empty*\"\n        float_values = []\n        integer_values = []\n        breakdown = []\n\n        for value in kwargs.values():\n            extract_numbers(value)\n\n        float_sum = sum(float_values)\n        integer_sum = sum(integer_values)\n        \n        float_log = \"\\n\".join([str(val) for val in float_values]) if float_values else empty\n        int_log = \"\\n\".join([str(val) for val in integer_values]) if integer_values else empty\n        breakdown_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(breakdown)]) if breakdown else empty\n\n        log = f\"\"\"## Result:\n  **Float sum: {str(float_sum)}**\n  **Integer sum: {str(integer_sum)}**\n\n## List of floats:\n  {float_log}\n\n## List of integers:\n  {int_log}\n\n## Breakdown:\n\n  {breakdown_log}\n    \"\"\"\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}something2number\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": log,\n        })\n\n        return (float_sum, integer_sum, float_values, integer_values)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_Something2Number:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {},\n            \"optional\": {\n                \"JSON\": (Input.JSON, {\n                    \"tooltip\": \"JSON value to convert to numbers.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"tooltip\": \"Boolean value to convert to numbers.\"\n                }),\n                \"string\": (Input.STRING, {\n                    \"tooltip\": \"String value to convert to numbers.\"\n                }),\n                \"integer\": (Input.INTEGER, {\n                    \"tooltip\": \"Integer value to convert to numbers.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"tooltip\": \"Float value to convert to numbers.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, False, False, False, True, True)\n    RETURN_NAMES = (\"float_sum\", \"int_sum\", \"float_list\", \"int_list\")\n    RETURN_TYPES = (\"FLOAT\", \"INT\", \"FLOAT\", \"INT\")\n\n    def on_exec(self, **kwargs: dict):\n        def extract_numbers(data):\n            if isinstance(data, bool):\n                i_val = 1 if data else 0\n                f_val = 1.0 if data else 0.0\n                float_values.append(f_val)\n                integer_values.append(i_val)\n                breakdown.append(f\"**boolean** detected => {f_val} (float) {i_val} (int)\")\n            elif isinstance(data, (int, float)):\n                i_val = int(data)\n                f_val = float(data)\n                float_values.append(f_val)\n                integer_values.append(i_val)\n                breakdown.append(f\"**number** detected => {f_val} (float) {i_val} (int)\")\n            elif isinstance(data, str):\n                try:\n                    f_val = float(data.strip())\n                    i_val = int(f_val)\n                    float_values.append(f_val)\n                    integer_values.append(i_val)\n                    breakdown.append(f\"**string** detected => {f_val} (float) {i_val} (int)\")\n                except ValueError:\n                    try:\n                        parsed_json = json.loads(data)\n                        extract_numbers(parsed_json)\n                    except json.JSONDecodeError:\n                        pass\n            elif isinstance(data, dict):\n                for value in data.values():\n                    extract_numbers(value)\n            elif isinstance(data, (list, tuple, set)):\n                for item in data:\n                    extract_numbers(item)\n\n        empty = \"*Empty*\"\n        float_values = []\n        integer_values = []\n        breakdown = []\n\n        for value in kwargs.values():\n            extract_numbers(value)\n\n        float_sum = sum(float_values)\n        integer_sum = sum(integer_values)\n        \n        float_log = \"\\n\".join([str(val) for val in float_values]) if float_values else empty\n        int_log = \"\\n\".join([str(val) for val in integer_values]) if integer_values else empty\n        breakdown_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(breakdown)]) if breakdown else empty\n\n        log = f\"\"\"## Result:\n  **Float sum: {str(float_sum)}**\n  **Integer sum: {str(integer_sum)}**\n\n## List of floats:\n  {float_log}\n\n## List of integers:\n  {int_log}\n\n## Breakdown:\n\n  {breakdown_log}\n    \"\"\"\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}something2number\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": log,\n        })\n\n        return (float_sum, integer_sum, float_values, integer_values)"},{"icon":"history","id":"class LF_Something2String:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"\n                }),\n            },\n            \"optional\": {\n                \"json\": (Input.JSON, {\n                    \"tooltip\": \"JSON value to convert to string.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"tooltip\": \"Boolean value to convert to string.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"tooltip\": \"Float value to convert to string.\"\n                }),\n                \"integer\": (Input.INTEGER, {\n                    \"tooltip\": \"Integer value to convert to string.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n\n    input_keys = [\"json\", \"boolean\", \"float\", \"integer\"]\n    combinations_list = []\n\n    for r in range(1, len(input_keys) + 1):\n        for combo in combinations(input_keys, r):\n            combo_name = \"_\".join(combo)\n            combinations_list.append(combo_name)\n\n    OUTPUT_IS_LIST = tuple([False] * len(combinations_list))\n    RETURN_TYPES = tuple([\"STRING\"] * len(combinations_list))\n    RETURN_NAMES = tuple(combinations_list)\n\n    def on_exec(self, **kwargs: dict):\n        def flatten_input(input_item):\n            if isinstance(input_item, list):\n                return [str(sub_item) for item in input_item for sub_item in flatten_input(item)]\n            elif isinstance(input_item, (dict, bool, float, int)):\n                flattened_value = str(input_item)\n                breakdown.append(f\"**{type(input_item).__name__}** detected => {flattened_value}\")\n                return [flattened_value]\n            elif input_item is not None:\n                flattened_value = str(input_item)\n                breakdown.append(f\"**string** detected => {flattened_value}\")\n                return [flattened_value]\n            return []\n\n        separator = kwargs.get(\"separator\", \", \")\n        breakdown = []\n\n        results = []\n        combination_logs = []\n\n        for combo_name in self.RETURN_NAMES:\n            items = combo_name.split(\"_\")\n            flattened_combo = []\n\n            for item in items:\n                if item in kwargs:\n                    flattened_combo.extend(flatten_input(kwargs[item]))\n\n            combined_string = separator.join(flattened_combo)\n            results.append(combined_string)\n            combination_logs.append(f\"**{combo_name}** => {combined_string}\")\n\n        flattened_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(breakdown)]) if breakdown else \"*Empty*\"\n        combinations_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(combination_logs)]) if combination_logs else \"*Empty*\"\n\n        log = f\"\"\"## Breakdown\n\n{flattened_log}\n\n## Combination Results:\n{combinations_log}\n        \"\"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}something2string\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": log,\n        })\n\n        return tuple(results)","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_Something2String:\n    @classmethod\n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"\n                }),\n            },\n            \"optional\": {\n                \"json\": (Input.JSON, {\n                    \"tooltip\": \"JSON value to convert to string.\"\n                }),\n                \"boolean\": (Input.BOOLEAN, {\n                    \"tooltip\": \"Boolean value to convert to string.\"\n                }),\n                \"float\": (Input.FLOAT, {\n                    \"tooltip\": \"Float value to convert to string.\"\n                }),\n                \"integer\": (Input.INTEGER, {\n                    \"tooltip\": \"Integer value to convert to string.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n\n    input_keys = [\"json\", \"boolean\", \"float\", \"integer\"]\n    combinations_list = []\n\n    for r in range(1, len(input_keys) + 1):\n        for combo in combinations(input_keys, r):\n            combo_name = \"_\".join(combo)\n            combinations_list.append(combo_name)\n\n    OUTPUT_IS_LIST = tuple([False] * len(combinations_list))\n    RETURN_TYPES = tuple([\"STRING\"] * len(combinations_list))\n    RETURN_NAMES = tuple(combinations_list)\n\n    def on_exec(self, **kwargs: dict):\n        def flatten_input(input_item):\n            if isinstance(input_item, list):\n                return [str(sub_item) for item in input_item for sub_item in flatten_input(item)]\n            elif isinstance(input_item, (dict, bool, float, int)):\n                flattened_value = str(input_item)\n                breakdown.append(f\"**{type(input_item).__name__}** detected => {flattened_value}\")\n                return [flattened_value]\n            elif input_item is not None:\n                flattened_value = str(input_item)\n                breakdown.append(f\"**string** detected => {flattened_value}\")\n                return [flattened_value]\n            return []\n\n        separator = kwargs.get(\"separator\", \", \")\n        breakdown = []\n\n        results = []\n        combination_logs = []\n\n        for combo_name in self.RETURN_NAMES:\n            items = combo_name.split(\"_\")\n            flattened_combo = []\n\n            for item in items:\n                if item in kwargs:\n                    flattened_combo.extend(flatten_input(kwargs[item]))\n\n            combined_string = separator.join(flattened_combo)\n            results.append(combined_string)\n            combination_logs.append(f\"**{combo_name}** => {combined_string}\")\n\n        flattened_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(breakdown)]) if breakdown else \"*Empty*\"\n        combinations_log = \"\\n\".join([f\"{i+1}. {val}\" for i, val in enumerate(combination_logs)]) if combination_logs else \"*Empty*\"\n\n        log = f\"\"\"## Breakdown\n\n{flattened_log}\n\n## Combination Results:\n{combinations_log}\n        \"\"\"\n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}something2string\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": log,\n        })\n\n        return tuple(results)"},{"icon":"history","id":"class LF_String:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        string_input: str = normalize_list_to_value(kwargs.get(\"string\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(string_input, nodes)\n\n        if randomize:\n            string_input = randomize_from_history(nodes, seed)        \n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}string\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"dataset\": dataset,\n        })\n\n        return (string_input, [string_input])","description":"Execution date: 24/09/2025, 09:44:17.","value":"class LF_String:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"string\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"String value.\"\n                }),\n                \"enable_history\": (Input.BOOLEAN, {\n                    \"default\": True, \n                    \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"\n                }),\n                \"randomize\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Randomly selects a previously used value (must be present in the history list).\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness when 'randomize' is active.\"\n                }),\n            },\n            \"optional\": {\n                \"ui_widget\": (Input.LF_HISTORY, {\n                    \"default\": {}\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        string_input: str = normalize_list_to_value(kwargs.get(\"string\"))\n        enable_history: bool = normalize_list_to_value(kwargs.get(\"enable_history\"))\n        randomize: bool = normalize_list_to_value(kwargs.get(\"randomize\"))\n        seed: int = normalize_list_to_value(kwargs.get(\"seed\"))\n        ui_widget: dict = normalize_json_input(kwargs.get(\"ui_widget\", {}))\n\n        nodes = ui_widget.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(string_input, nodes)\n\n        if randomize:\n            string_input = randomize_from_history(nodes, seed)        \n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}string\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"dataset\": dataset,\n        })\n\n        return (string_input, [string_input])"}]}],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":6,"type":"LF_DisplayJSON","pos":[725,135],"size":[650,995],"flags":{},"order":3,"mode":0,"inputs":[{"localized_name":"json_input","name":"json_input","type":"JSON","link":46},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"json","name":"json","type":"JSON","slot_index":0,"links":[]}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_DisplayJSON","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["{\n  \"file\": \"F:\\\\primitives.py\",\n  \"name\": \"LF_WallOfText\",\n  \"code\": \"class LF_WallOfText:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"}),\\n                \\\"text_1\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The first required string.\\\"}),\\n                \\\"text_2\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The second required string.\\\"}),\\n            },\\n            \\\"optional\\\": {\\n                \\\"text_3\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The third optional string.\\\"\\n                }),\\n                \\\"text_4\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fourth optional string.\\\"\\n                }),\\n                \\\"text_5\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fifth optional string.\\\"\\n                }),\\n                \\\"text_6\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The sixth optional string.\\\"\\n                }),\\n                \\\"text_7\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The seventh optional string.\\\"\\n                }),\\n                \\\"text_8\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The eighth optional string.\\\"\\n                }),\\n                \\\"text_9\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The ninth optional string.\\\"\\n                }),\\n                \\\"text_10\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The tenth optional string.\\\"\\n                }),\\n                \\\"shuffle_inputs\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Toggle shuffling of input strings.\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness of the shuffling.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\\\"text_{i}\\\", \\\"\\\")) for i in range(1, 11)]\\n\\n        if len(texts) > 1:\\n            separator = kwargs.get(\\\"separator\\\", \\\"\\\")\\n            shuffle_inputs = kwargs.get(\\\"shuffle_inputs\\\", False)\\n            if shuffle_inputs:\\n                seed = kwargs.get(\\\"seed\\\", 42)\\n                random.seed(seed)\\n                random.shuffle(texts)\\n            wall_of_text = separator.join([text for text in texts if text])\\n        else:\\n            wall_of_text = texts[0]\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}walloftext\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": wall_of_text,\\n        })\\n\\n        return (wall_of_text, wall_of_text)\",\n  \"constants\": [\n    \"STRING\",\n    \"BOOLEAN\",\n    \"INPUT_TYPES\",\n    \"INT_MAX\",\n    \"LF_CODE\",\n    \"EVENT_PREFIX\",\n    \"UNIQUE_ID\",\n    \"INTEGER\"\n  ],\n  \"helperFunctions\": [\n    \"len\",\n    \"join\",\n    \"get\",\n    \"range\",\n    \"return\",\n    \"Character\",\n    \"send_sync\",\n    \"seed\",\n    \"normalize_list_to_value\",\n    \"shuffle\"\n  ]\n}"],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":29,"type":"LF_GetValueFromJSON","pos":[725,-1130],"size":[295,495],"flags":{},"order":5,"mode":0,"inputs":[{"localized_name":"json_input","name":"json_input","type":"JSON","link":49},{"localized_name":"key","name":"key","type":"STRING","widget":{"name":"key"},"link":null},{"localized_name":"index","name":"index","type":"INT","widget":{"name":"index"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"json","name":"json","type":"JSON","slot_index":0,"links":null},{"localized_name":"string","name":"string","type":"STRING","slot_index":1,"links":[50]},{"localized_name":"number","name":"number","type":"NUMBER","links":null},{"localized_name":"int","name":"int","type":"INT","links":null},{"localized_name":"float","name":"float","type":"FLOAT","links":null},{"localized_name":"boolean","name":"boolean","type":"BOOLEAN","links":null}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_GetValueFromJSON","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["helperFunctions",0,"## Selected key\nhelperFunctions\n\n## Content:\n['len', 'join', 'get', 'range', 'return', 'Character', 'send_sync', 'seed', 'normalize_list_to_value', 'shuffle']"],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":8,"type":"LF_GetValueFromJSON","pos":[725,-565],"size":[290,605],"flags":{},"order":4,"mode":0,"inputs":[{"localized_name":"json_input","name":"json_input","type":"JSON","link":47},{"localized_name":"key","name":"key","type":"STRING","widget":{"name":"key"},"link":null},{"localized_name":"index","name":"index","type":"INT","widget":{"name":"index"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"json","name":"json","type":"JSON","slot_index":0,"links":null},{"localized_name":"string","name":"string","type":"STRING","slot_index":1,"links":[37]},{"localized_name":"number","name":"number","type":"NUMBER","links":null},{"localized_name":"int","name":"int","type":"INT","links":null},{"localized_name":"float","name":"float","type":"FLOAT","links":null},{"localized_name":"boolean","name":"boolean","type":"BOOLEAN","links":null}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_GetValueFromJSON","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["code",0,"## Selected key\ncode\n\n## Content:\nclass LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)"],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":28,"type":"LF_DisplayString","pos":[1055,-1110],"size":[285,475],"flags":{},"order":7,"mode":0,"inputs":[{"localized_name":"string","name":"string","type":"STRING","link":50},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"string","name":"string","type":"STRING","slot_index":0,"links":null}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_DisplayString","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["['len', 'join', 'get', 'range', 'return', 'Character', 'send_sync', 'seed', 'normalize_list_to_value', 'shuffle']"],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":21,"type":"LF_MarkdownDocGenerator","pos":[2020,-860],"size":[315,800],"flags":{},"order":8,"mode":0,"inputs":[{"localized_name":"prompt","name":"prompt","type":"STRING","widget":{"name":"prompt"},"link":38},{"localized_name":"temperature","name":"temperature","type":"FLOAT","widget":{"name":"temperature"},"link":null},{"localized_name":"max_tokens","name":"max_tokens","type":"INT","widget":{"name":"max_tokens"},"link":null},{"localized_name":"seed","name":"seed","type":"INT","widget":{"name":"seed"},"link":null},{"localized_name":"url","name":"url","type":"STRING","widget":{"name":"url"},"link":null},{"localized_name":"extra_context","name":"extra_context","shape":7,"type":"STRING","widget":{"name":"extra_context"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"request_json","name":"request_json","type":"JSON","links":null},{"localized_name":"response_json","name":"response_json","type":"JSON","links":null},{"localized_name":"markdown","name":"markdown","type":"STRING","slot_index":2,"links":[]},{"localized_name":"markdown_list","name":"markdown_list","shape":6,"type":"STRING","slot_index":3,"links":[39]}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_MarkdownDocGenerator"},"widgets_values":["",0.5,2000,5834649184486,"randomize","http://localhost:5001/v1/chat/completions","","Here is the Markdown documentation for the `LF_Something2Number` class:\n\n# LF_Something2Number\n\n### Summary\nConverts various input types (JSON, boolean, string, integer, float, and UI widgets) to numbers (floats and integers) and returns summary statistics and a breakdown of the conversion process.\n\n---\n\n##  Inputs\n\n| Parameter      | Type     | Default Value | Description |\n|----------------|----------|---------------|-------------|\n| required       | dict     | -             | Input values to be converted to numbers |\n| optional       | JSON, boolean, string, integer, float, ui_widget | -             | Optional input values to be converted to numbers |\n| hidden         | node_id  | UNIQUE_ID     | Node ID for event logging |\n\n---\n\n##  Outputs\n\n| Output Name    | Type     | Description |\n|----------------|----------|-------------|\n| float_sum      | FLOAT    | Sum of all float values |\n| integer_sum    | INT      | Sum of all integer values |\n| float_list     | LIST(FLOAT) | List of all float values |\n| integer_list   | LIST(INT) | List of all integer values |\n\n---\n\n##  Execution Details\n\n- **Category**: {CATEGORY}\n- **Function Name**: `something2number`\n- **Execution Method**: `on_exec`\n- **Unique Features**: Supports parsing JSON strings, detecting boolean values, and logging conversion breakdowns\n\n---\n\n###  Example Output\n```json\n{\n  \"float_sum\": 12.5,\n  \"integer_sum\": 25,\n  \"float_list\": [1.0, 2.0, 3.0],\n  \"integer_list\": [1, 2, 3]\n}\n```\nNote: The actual output will depend on the input values and their conversion results. The example output above illustrates the expected format of the returned values."],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":30,"type":"LF_ControlPanel","pos":[-415,-1970],"size":[1125,1955],"flags":{},"order":0,"mode":0,"inputs":[{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CONTROL_PANEL","widget":{"name":"ui_widget"},"link":null}],"outputs":[],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_ControlPanel"},"widgets_values":[{"backup":true,"debug":true,"themes":"light"}],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":27,"type":"LF_RegionExtractor","pos":[240,55],"size":[470,1075],"flags":{},"order":1,"mode":0,"inputs":[{"localized_name":"dir","name":"dir","type":"STRING","widget":{"name":"dir"},"link":null},{"localized_name":"subdir","name":"subdir","type":"BOOLEAN","widget":{"name":"subdir"},"link":null},{"localized_name":"enable_history","name":"enable_history","type":"BOOLEAN","widget":{"name":"enable_history"},"link":null},{"localized_name":"extension","name":"extension","type":"STRING","widget":{"name":"extension"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_HISTORY","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"regions","name":"regions","type":"JSON","links":[45]},{"localized_name":"regions_list","name":"regions_list","shape":6,"type":"JSON","slot_index":1,"links":[46,47,49]}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_RegionExtractor","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["F:\\",false,false,"py",{"nodes":[{"icon":"history","id":"LF_DisplayBoolean","description":"Execution date: 31/10/2024, 05:41:37.","value":"LF_DisplayBoolean"}]}],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":24,"type":"LF_SaveMarkdown","pos":[2355,-800],"size":[385,525],"flags":{},"order":9,"mode":0,"inputs":[{"localized_name":"markdown_text","name":"markdown_text","type":"STRING","widget":{"name":"markdown_text"},"link":39},{"localized_name":"filename_prefix","name":"filename_prefix","type":"STRING","widget":{"name":"filename_prefix"},"link":null},{"localized_name":"add_timestamp","name":"add_timestamp","type":"BOOLEAN","widget":{"name":"add_timestamp"},"link":null},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_TREE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"string","name":"string","type":"STRING","slot_index":0,"links":[51]}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_SaveMarkdown","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["","",true,{"nodes":[{"children":[{"description":"C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md","icon":"article","id":"C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md","value":"C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md"}],"icon":"check","id":"root","value":"Markdown saved successfully!"}]}],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":5,"type":"LF_DisplayJSON","pos":[1390,55],"size":[1350,1075],"flags":{},"order":2,"mode":0,"inputs":[{"localized_name":"json_input","name":"json_input","type":"JSON","link":45},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"json","name":"json","type":"JSON","links":null}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_DisplayJSON","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["[\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Boolean\",\n    \"code\": \"class LF_Boolean:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"boolean\\\", \\\"boolean_list\\\")\\n    RETURN_TYPES = (\\\"BOOLEAN\\\", \\\"BOOLEAN\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        boolean: bool = normalize_list_to_value(kwargs.get(\\\"boolean\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes: list[dict] = ui_widget.get(\\\"nodes\\\", [])\\n        dataset: dict = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(boolean), nodes)\\n\\n        if randomize:\\n            result = randomize_from_history(nodes, seed)\\n            boolean = True if result.lower() == \\\"true\\\" else False\\n            \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}boolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (boolean, [boolean])\",\n    \"constants\": [\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"INT_MAX\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"LF_HISTORY\"\n    ],\n    \"helperFunctions\": [\n      \"randomize_from_history\",\n      \"lower\",\n      \"value\",\n      \"get\",\n      \"return\",\n      \"str\",\n      \"normalize_json_input\",\n      \"send_sync\",\n      \"normalize_list_to_value\",\n      \"create_history_node\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayBoolean\",\n    \"code\": \"class LF_DisplayBoolean:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"boolean\\\",)\\n    RETURN_TYPES = (\\\"BOOLEAN\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_boolean: bool = normalize_input_list(kwargs.get(\\\"boolean\\\"))\\n\\n        if isinstance(display_boolean, list):\\n            if len(display_boolean) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_boolean))\\n            else:\\n                markdown_value = str(display_boolean[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayboolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"boolean\\\"),)\",\n    \"constants\": [\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"len\",\n      \"join\",\n      \"get\",\n      \"return\",\n      \"isinstance\",\n      \"str\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayFloat\",\n    \"code\": \"class LF_DisplayFloat:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"float\\\",)\\n    RETURN_TYPES = (\\\"FLOAT\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_float: float = normalize_input_list(kwargs.get(\\\"float\\\"))\\n\\n        if isinstance(display_float, list):\\n            if len(display_float) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_float))\\n            else:\\n                markdown_value = str(display_float[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayfloat\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"float\\\"),)\",\n    \"constants\": [\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"FLOAT\"\n    ],\n    \"helperFunctions\": [\n      \"len\",\n      \"join\",\n      \"get\",\n      \"return\",\n      \"isinstance\",\n      \"str\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayInteger\",\n    \"code\": \"class LF_DisplayInteger:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"integer\\\",)\\n    RETURN_TYPES = (\\\"INT\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_integer: int = normalize_input_list(kwargs.get(\\\"integer\\\"))\\n\\n        if isinstance(display_integer, list):\\n            if len(display_integer) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_integer))\\n            else:\\n                markdown_value = str(display_integer[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayinteger\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"integer\\\"),)\",\n    \"constants\": [\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"INT\",\n      \"UNIQUE_ID\",\n      \"INTEGER\"\n    ],\n    \"helperFunctions\": [\n      \"len\",\n      \"join\",\n      \"get\",\n      \"return\",\n      \"isinstance\",\n      \"str\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayPrimitiveAsJSON\",\n    \"code\": \"class LF_DisplayPrimitiveAsJSON:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {},\\n            \\\"optional\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0.0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"step\\\": 0.1, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"forceInput\\\": True, \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"json\\\",)\\n    RETURN_TYPES = (\\\"JSON\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        integer_list: int = normalize_input_list(kwargs.get(\\\"integer\\\"))\\n        float_list: float = normalize_input_list(kwargs.get(\\\"float\\\"))\\n        string_list: str = normalize_input_list(kwargs.get(\\\"string\\\"))\\n        boolean_list: bool = normalize_input_list(kwargs.get(\\\"boolean\\\"))\\n\\n        nodes: list[dict] = []\\n        dataset: dict = {\\\"nodes\\\": nodes}\\n\\n        if boolean_list:\\n            for idx, value in enumerate(boolean_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"boolean_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"boolean_{idx}\\\", \\\"value\\\": \\\"boolean\\\"\\n                })\\n        \\n        if float_list:\\n            for idx, value in enumerate(float_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"float_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"float_{idx}\\\", \\\"value\\\": \\\"float\\\"\\n                })\\n        \\n        if integer_list:\\n            for idx, value in enumerate(integer_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"integer_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"integer_{idx}\\\", \\\"value\\\": \\\"integer\\\"\\n                })\\n        \\n        if string_list:\\n            for idx, value in enumerate(string_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"string_{idx}\\\", \\\"value\\\": value}],\\n                    \\\"description\\\": value, \\\"id\\\": f\\\"string_{idx}\\\", \\\"value\\\": \\\"string\\\"\\n                })\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayprimitiveasjson\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": dataset,\\n        })\\n\\n        return (dataset,)\",\n    \"constants\": [\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"JSON\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"FLOAT\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"return\",\n      \"str\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"send_sync\",\n      \"append\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayString\",\n    \"code\": \"class LF_DisplayString:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"string\\\",)\\n    RETURN_TYPES = (\\\"STRING\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_string:str = normalize_input_list(kwargs.get(\\\"string\\\"))\\n\\n        if isinstance(display_string, list):\\n            if len(display_string) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_string))\\n            else:\\n                markdown_value = display_string[0]\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displaystring\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"string\\\"),)\",\n    \"constants\": [\n      \"STRING\",\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"len\",\n      \"join\",\n      \"get\",\n      \"return\",\n      \"isinstance\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Float\",\n    \"code\": \"class LF_Float:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0, \\n                    \\\"step\\\": 0.1, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"float\\\", \\\"float_list\\\")\\n    RETURN_TYPES = (\\\"FLOAT\\\", \\\"FLOAT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        float_input: float = normalize_list_to_value(kwargs.get(\\\"float\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(float_input), nodes)\\n\\n        if randomize:\\n            float_input = float(randomize_from_history(nodes, seed))\\n                \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}float\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (float_input, [float_input])\",\n    \"constants\": [\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"INT_MAX\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"FLOAT\",\n      \"LF_HISTORY\"\n    ],\n    \"helperFunctions\": [\n      \"randomize_from_history\",\n      \"value\",\n      \"get\",\n      \"float\",\n      \"return\",\n      \"str\",\n      \"normalize_json_input\",\n      \"send_sync\",\n      \"normalize_list_to_value\",\n      \"create_history_node\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Integer\",\n    \"code\": \"class LF_Integer:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"int\\\", \\\"int_list\\\")\\n    RETURN_TYPES = (\\\"INT\\\", \\\"INT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        integer_input: int = normalize_list_to_value(kwargs.get(\\\"integer\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(integer_input), nodes)\\n\\n        if randomize:\\n            integer_input = int(randomize_from_history(nodes, seed))\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}integer\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset\\n        })\\n\\n        return (integer_input, [integer_input])\",\n    \"constants\": [\n      \"BOOLEAN\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"EVENT_PREFIX\",\n      \"INT\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"LF_HISTORY\"\n    ],\n    \"helperFunctions\": [\n      \"randomize_from_history\",\n      \"value\",\n      \"get\",\n      \"return\",\n      \"str\",\n      \"normalize_json_input\",\n      \"send_sync\",\n      \"normalize_list_to_value\",\n      \"create_history_node\",\n      \"int\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_RandomBoolean\",\n    \"code\": \"class LF_RandomBoolean:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"chance_true\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 50.0, \\n                    \\\"step\\\": 1, \\n                    \\\"min\\\": 0, \\n                    \\\"max\\\": 100, \\n                    \\\"tooltip\\\": \\\"Percentage chance for True output, 0-100.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_PROGRESSBAR, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"boolean\\\", \\\"boolean_list\\\")\\n    RETURN_TYPES = (\\\"BOOLEAN\\\", \\\"BOOLEAN\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        chance_true: str = normalize_list_to_value(kwargs.get(\\\"chance_true\\\"))\\n        \\n        percentage = max(0, min(100, chance_true))\\n        random_value = random.uniform(0, 100)\\n\\n        result = random_value <= percentage\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}randomboolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"bool\\\": result,\\n            \\\"roll\\\": random_value,\\n        })\\n\\n        return (result, [result])\\n\\n    @classmethod\\n    def IS_CHANGED(cls, **kwargs):\\n        return float(\\\"NaN\\\")\",\n    \"constants\": [\n      \"IS_CHANGED\",\n      \"LF_PROGRESSBAR\",\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"FLOAT\"\n    ],\n    \"helperFunctions\": [\n      \"max\",\n      \"get\",\n      \"return\",\n      \"float\",\n      \"send_sync\",\n      \"normalize_list_to_value\",\n      \"min\",\n      \"uniform\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Something2Number\",\n    \"code\": \"class LF_Something2Number:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {},\\n            \\\"optional\\\": {\\n                \\\"JSON\\\": (Input.JSON, {\\n                    \\\"tooltip\\\": \\\"JSON value to convert to numbers.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"tooltip\\\": \\\"Boolean value to convert to numbers.\\\"\\n                }),\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"tooltip\\\": \\\"String value to convert to numbers.\\\"\\n                }),\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"tooltip\\\": \\\"Integer value to convert to numbers.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"tooltip\\\": \\\"Float value to convert to numbers.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, False, False, False, True, True)\\n    RETURN_NAMES = (\\\"float_sum\\\", \\\"int_sum\\\", \\\"float_list\\\", \\\"int_list\\\")\\n    RETURN_TYPES = (\\\"FLOAT\\\", \\\"INT\\\", \\\"FLOAT\\\", \\\"INT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        def extract_numbers(data):\\n            if isinstance(data, bool):\\n                i_val = 1 if data else 0\\n                f_val = 1.0 if data else 0.0\\n                float_values.append(f_val)\\n                integer_values.append(i_val)\\n                breakdown.append(f\\\"**boolean** detected => {f_val} (float) {i_val} (int)\\\")\\n            elif isinstance(data, (int, float)):\\n                i_val = int(data)\\n                f_val = float(data)\\n                float_values.append(f_val)\\n                integer_values.append(i_val)\\n                breakdown.append(f\\\"**number** detected => {f_val} (float) {i_val} (int)\\\")\\n            elif isinstance(data, str):\\n                try:\\n                    f_val = float(data.strip())\\n                    i_val = int(f_val)\\n                    float_values.append(f_val)\\n                    integer_values.append(i_val)\\n                    breakdown.append(f\\\"**string** detected => {f_val} (float) {i_val} (int)\\\")\\n                except ValueError:\\n                    try:\\n                        parsed_json = json.loads(data)\\n                        extract_numbers(parsed_json)\\n                    except json.JSONDecodeError:\\n                        pass\\n            elif isinstance(data, dict):\\n                for value in data.values():\\n                    extract_numbers(value)\\n            elif isinstance(data, (list, tuple, set)):\\n                for item in data:\\n                    extract_numbers(item)\\n\\n        empty = \\\"*Empty*\\\"\\n        float_values = []\\n        integer_values = []\\n        breakdown = []\\n\\n        for value in kwargs.values():\\n            extract_numbers(value)\\n\\n        float_sum = sum(float_values)\\n        integer_sum = sum(integer_values)\\n        \\n        float_log = \\\"\\\\n\\\".join([str(val) for val in float_values]) if float_values else empty\\n        int_log = \\\"\\\\n\\\".join([str(val) for val in integer_values]) if integer_values else empty\\n        breakdown_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(breakdown)]) if breakdown else empty\\n\\n        log = f\\\"\\\"\\\"## Result:\\n  **Float sum: {str(float_sum)}**\\n  **Integer sum: {str(integer_sum)}**\\n\\n## List of floats:\\n  {float_log}\\n\\n## List of integers:\\n  {int_log}\\n\\n## Breakdown:\\n\\n  {breakdown_log}\\n    \\\"\\\"\\\"\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}something2number\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": log,\\n        })\\n\\n        return (float_sum, integer_sum, float_values, integer_values)\",\n    \"constants\": [\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"JSON\",\n      \"EVENT_PREFIX\",\n      \"INT\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"FLOAT\"\n    ],\n    \"helperFunctions\": [\n      \"sum\",\n      \"join\",\n      \"get\",\n      \"float\",\n      \"isinstance\",\n      \"return\",\n      \"str\",\n      \"strip\",\n      \"loads\",\n      \"int\",\n      \"enumerate\",\n      \"send_sync\",\n      \"values\",\n      \"append\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Something2String\",\n    \"code\": \"class LF_Something2String:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"json\\\": (Input.JSON, {\\n                    \\\"tooltip\\\": \\\"JSON value to convert to string.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"tooltip\\\": \\\"Boolean value to convert to string.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"tooltip\\\": \\\"Float value to convert to string.\\\"\\n                }),\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"tooltip\\\": \\\"Integer value to convert to string.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n\\n    input_keys = [\\\"json\\\", \\\"boolean\\\", \\\"float\\\", \\\"integer\\\"]\\n    combinations_list = []\\n\\n    for r in range(1, len(input_keys) + 1):\\n        for combo in combinations(input_keys, r):\\n            combo_name = \\\"_\\\".join(combo)\\n            combinations_list.append(combo_name)\\n\\n    OUTPUT_IS_LIST = tuple([False] * len(combinations_list))\\n    RETURN_TYPES = tuple([\\\"STRING\\\"] * len(combinations_list))\\n    RETURN_NAMES = tuple(combinations_list)\\n\\n    def on_exec(self, **kwargs: dict):\\n        def flatten_input(input_item):\\n            if isinstance(input_item, list):\\n                return [str(sub_item) for item in input_item for sub_item in flatten_input(item)]\\n            elif isinstance(input_item, (dict, bool, float, int)):\\n                flattened_value = str(input_item)\\n                breakdown.append(f\\\"**{type(input_item).__name__}** detected => {flattened_value}\\\")\\n                return [flattened_value]\\n            elif input_item is not None:\\n                flattened_value = str(input_item)\\n                breakdown.append(f\\\"**string** detected => {flattened_value}\\\")\\n                return [flattened_value]\\n            return []\\n\\n        separator = kwargs.get(\\\"separator\\\", \\\", \\\")\\n        breakdown = []\\n\\n        results = []\\n        combination_logs = []\\n\\n        for combo_name in self.RETURN_NAMES:\\n            items = combo_name.split(\\\"_\\\")\\n            flattened_combo = []\\n\\n            for item in items:\\n                if item in kwargs:\\n                    flattened_combo.extend(flatten_input(kwargs[item]))\\n\\n            combined_string = separator.join(flattened_combo)\\n            results.append(combined_string)\\n            combination_logs.append(f\\\"**{combo_name}** => {combined_string}\\\")\\n\\n        flattened_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(breakdown)]) if breakdown else \\\"*Empty*\\\"\\n        combinations_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(combination_logs)]) if combination_logs else \\\"*Empty*\\\"\\n\\n        log = f\\\"\\\"\\\"## Breakdown\\n\\n{flattened_log}\\n\\n## Combination Results:\\n{combinations_log}\\n        \\\"\\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}something2string\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": log,\\n        })\\n\\n        return tuple(results)\",\n    \"constants\": [\n      \"_\",\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"LF_CODE\",\n      \"JSON\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"FLOAT\"\n    ],\n    \"helperFunctions\": [\n      \"extend\",\n      \"join\",\n      \"tuple\",\n      \"type\",\n      \"get\",\n      \"isinstance\",\n      \"str\",\n      \"split\",\n      \"combinations\",\n      \"len\",\n      \"range\",\n      \"Character\",\n      \"enumerate\",\n      \"send_sync\",\n      \"append\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_String\",\n    \"code\": \"class LF_String:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        string_input: str = normalize_list_to_value(kwargs.get(\\\"string\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(string_input, nodes)\\n\\n        if randomize:\\n            string_input = randomize_from_history(nodes, seed)        \\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}string\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (string_input, [string_input])\",\n    \"constants\": [\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"INT_MAX\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\",\n      \"LF_HISTORY\"\n    ],\n    \"helperFunctions\": [\n      \"randomize_from_history\",\n      \"value\",\n      \"get\",\n      \"return\",\n      \"normalize_json_input\",\n      \"send_sync\",\n      \"normalize_list_to_value\",\n      \"create_history_node\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_WallOfText\",\n    \"code\": \"class LF_WallOfText:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"}),\\n                \\\"text_1\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The first required string.\\\"}),\\n                \\\"text_2\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The second required string.\\\"}),\\n            },\\n            \\\"optional\\\": {\\n                \\\"text_3\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The third optional string.\\\"\\n                }),\\n                \\\"text_4\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fourth optional string.\\\"\\n                }),\\n                \\\"text_5\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fifth optional string.\\\"\\n                }),\\n                \\\"text_6\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The sixth optional string.\\\"\\n                }),\\n                \\\"text_7\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The seventh optional string.\\\"\\n                }),\\n                \\\"text_8\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The eighth optional string.\\\"\\n                }),\\n                \\\"text_9\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The ninth optional string.\\\"\\n                }),\\n                \\\"text_10\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The tenth optional string.\\\"\\n                }),\\n                \\\"shuffle_inputs\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Toggle shuffling of input strings.\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness of the shuffling.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\\\"text_{i}\\\", \\\"\\\")) for i in range(1, 11)]\\n\\n        if len(texts) > 1:\\n            separator = kwargs.get(\\\"separator\\\", \\\"\\\")\\n            shuffle_inputs = kwargs.get(\\\"shuffle_inputs\\\", False)\\n            if shuffle_inputs:\\n                seed = kwargs.get(\\\"seed\\\", 42)\\n                random.seed(seed)\\n                random.shuffle(texts)\\n            wall_of_text = separator.join([text for text in texts if text])\\n        else:\\n            wall_of_text = texts[0]\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}walloftext\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": wall_of_text,\\n        })\\n\\n        return (wall_of_text, wall_of_text)\",\n    \"constants\": [\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INPUT_TYPES\",\n      \"INT_MAX\",\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"UNIQUE_ID\",\n      \"INTEGER\"\n    ],\n    \"helperFunctions\": [\n      \"len\",\n      \"join\",\n      \"get\",\n      \"range\",\n      \"return\",\n      \"Character\",\n      \"send_sync\",\n      \"seed\",\n      \"normalize_list_to_value\",\n      \"shuffle\"\n    ]\n  }\n]"],"color":"#ffffff","bgcolor":"#ffffff","shape":1},{"id":10,"type":"LF_DisplayString","pos":[2760,-800],"size":[925,1930],"flags":{},"order":10,"mode":0,"inputs":[{"localized_name":"string","name":"string","type":"STRING","link":51},{"localized_name":"ui_widget","name":"ui_widget","shape":7,"type":"LF_CODE","widget":{"name":"ui_widget"},"link":null}],"outputs":[{"localized_name":"string","name":"string","type":"STRING","links":null}],"properties":{"cnr_id":"lf-nodes","ver":"7d49e4e1a0ac9c7cf311c20e769bbb20f7040943","Node name for S&R":"LF_DisplayString","ttNbgOverride":{"color":"#222","bgcolor":"#000","groupcolor":"#444"}},"widgets_values":["# LF_WallOfText\n\n### Summary\nThe LF_WallOfText node generates a wall of text by concatenating input strings, optionally shuffling them, and sending the result to the PromptServer.\n\n---\n\n##  Inputs\n\n| Parameter      | Type     | Default Value | Description |\n|----------------|----------|---------------|-------------|\n| separator      | STRING   | \", \"          | Character(s) separating each string apart. |\n| text_1         | STRING   | \"\"            | The first required string. |\n| text_2         | STRING   | \"\"            | The second required string. |\n| text_3-10      | STRING   | \"\"            | The third to tenth optional strings. |\n| shuffle_inputs | BOOLEAN  | False         | Toggle shuffling of input strings. |\n| seed           | INTEGER  | 42            | Seed to control the randomness of the shuffling. |\n| ui_widget     | LF_CODE  | \"\"            | Custom UI widget for node configuration. |\n| node_id       | STRING   | UNIQUE_ID     | Node ID (hidden input). |\n\n---\n\n##  Outputs\n\n| Output Name    | Type     | Description |\n|----------------|----------|-------------|\n| string         | STRING   | The generated wall of text. |\n| string_list    | STRING   | The generated wall of text (always returns a single string). |\n\n---\n\n##  Execution Details\n\n- **Category**: {CATEGORY}\n- **Function Name**: `{FUNCTION}`\n- **Execution Method**: `on_exec`\n- **Unique Features**: Shuffling of input strings, customizable separator, and optional UI widget for node configuration.\n\n---\n\n###  Example Output\n```json\n{\n    \"string\": \"Hello, world! Foo bar baz qux\"\n}\n```\nNote: The actual output will depend on the input values and shuffling configuration."],"color":"#ffffff","bgcolor":"#ffffff","shape":1}],"links":[[37,8,1,25,0,"STRING"],[38,25,1,21,0,"STRING"],[39,21,3,24,0,"STRING"],[45,27,0,5,0,"JSON"],[46,27,1,6,0,"JSON"],[47,27,1,8,0,"JSON"],[49,27,1,29,0,"JSON"],[50,29,1,28,0,"STRING"],[51,24,0,10,0,"STRING"]],"groups":[],"config":{},"extra":{"ds":{"scale":0.5054470284993248,"offset":[227.95537403970053,1066.6895309989973]},"node_versions":{"lf-nodes":"efccb1d68317c58ee78cc65ff54c56bea3dc27d5"},"ue_links":[]},"version":0.4}